
def solve_inventory_dp():

    # --- 1. Define Problem Data ---
    data = {
        1: {'b': 70, 'mu': 25, 'c': 0.5},  # Demand, Fixed Order Cost, Storage Cost
        2: {'b': 40, 'mu': 30, 'c': 0.4},
        3: {'b': 50, 'mu': 37, 'c': 0.3},
        4: {'b': 60, 'mu': 52, 'c': 0.0}  # Storage cost c4 is not given, implying 0
    }
    n_weeks = 4

    # --- 2. Initialize DP Tables ---
    # f[i][s] will store the minimum cost from week i to the end, with starting inventory s
    # policy[i][s] will store the optimal order quantity for that state
    f = {i: {} for i in range(1, n_weeks + 2)}
    policy = {i: {} for i in range(1, n_weeks + 1)}

    # --- 3. Set Boundary Condition ---
    # At the beginning of week 5 (end of week 4), inventory must be 0, and cost is 0.
    # Any other ending inventory is infinitely costly (invalid).
    f[n_weeks + 1] = {0: 0}

    # --- 4. Solve using Backward Recursion ---
    # Iterate from the last week (4) back to the first (1)
    for i in range(n_weeks, 0, -1):

        # Determine the possible inventory levels (states) at the beginning of week i.
        # An optimal policy will only leave inventory that covers the exact demand
        # for a set of future weeks.
        possible_start_inventories = {0}
        if i == 2:
            possible_start_inventories.update({40, 90, 150})
        elif i == 3:
            possible_start_inventories.update({50, 110})
        elif i == 4:
            possible_start_inventories.add(60)
        # For i=1, the start inventory is always 0.

        for s_i in possible_start_inventories:
            min_cost_for_state = float('inf')
            best_order_quantity = -1

            # A decision consists of ordering enough to satisfy demand for weeks i through j.
            # This is a key property of this type of inventory problem (Wagner-Whitin).
            for j in range(i, n_weeks + 1):
                # Calculate the total demand from week i up to week j
                target_inv_after_order = sum(data[k]['b'] for k in range(i, j + 1))

                # We can't have started with more inventory than needed for this plan
                if s_i > target_inv_after_order:
                    continue

                order_quantity = target_inv_after_order - s_i
                order_cost = data[i]['mu'] if order_quantity > 0 else 0

                # Inventory at the end of week i (this becomes the state s_{i+1})
                ending_inventory = s_i + order_quantity - data[i]['b']
                storage_cost = data[i]['c'] * ending_inventory

                # Get the optimal cost-to-go from the next stage
                future_cost = f[i + 1].get(ending_inventory, float('inf'))

                # If future_cost is infinity, it means this path leads to an invalid final state
                if future_cost == float('inf'):
                    continue

                current_total_cost = order_cost + storage_cost + future_cost

                if current_total_cost < min_cost_for_state:
                    min_cost_for_state = current_total_cost
                    best_order_quantity = order_quantity

            # Store the optimal cost and decision for this state (s_i)
            f[i][s_i] = min_cost_for_state
            policy[i][s_i] = best_order_quantity

    # --- 5. Forward Pass to Determine and Print Optimal Plan ---
    print("## Optimal Ordering Plan ##")
    current_inventory = 0
    total_cost = f[1][0]

    for i in range(1, n_weeks + 1):
        order_amount = policy[i][current_inventory]

        if order_amount > 0:
            print(f"Week {i}: Start with {current_inventory} balls.  ->  Order {order_amount} balls.")
        else:
            print(f"Week {i}: Start with {current_inventory} balls.  ->  Do not order.")

        # Update inventory for the start of the next week
        current_inventory = current_inventory + order_amount - data[i]['b']

    print(f"\n Total minimum cost: {total_cost:.2f} EUR")


if __name__ == '__main__':
    solve_inventory_dp()
